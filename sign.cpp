/**********************************************************************************
 * Tool to sign a given binary with an RSA private key
 *
 * Copyright (C) 2004 Joe Fox All rights reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *********************************************************************************/

#include <iostream>
#include <iomanip>
#include <fstream>
#include <vector>
#include <string>
#include <cstring>
#include <cstdio>
#include <iterator>

#include <openssl/evp.h>
#include <openssl/pem.h>
#include <openssl/bio.h>

#include "signelf.h"
#include "privkey.h"	// for szKeyBuf (generated by "genkeypr priv <privkeyfile>")

int main(int argc, char **argv) {
	// assume success
	int nRetval = 0;
	signelf::UCharArray arHash;

	// open an .so for read using the default target
	arHash = signelf::hashLib(argv[1]);

	if (arHash.empty()) {
		// couldn't generate hash
		nRetval = 1;
	} else {
		// now generate the signature
		signelf::UCharArray arSig;
		arSig = signelf::signHash(reinterpret_cast<const unsigned char*>(&arHash[0]), arHash.size(), szKeyBuf, sizeof(szKeyBuf));

		if(arSig.empty()) {
			// couldn't generate signature
			nRetval = 2;
		} else {
			// write it to a sig file
			std::ofstream fOut("object.sig");
			if (!fOut) {
				// couldn't write sig
				nRetval = 3;
			} else {
				fOut.write(reinterpret_cast<char*>(&arSig[0]), arSig.size());
				fOut.close();

				std::string sCommandline("objcopy --add-section .lsesig=object.sig ");

				sCommandline += argv[1];

				// now copy the sig into the object
				nRetval = system(sCommandline.c_str());

				// remove the sig file
				std::remove("object.sig");
			}
		}
	}

	return nRetval;
}
